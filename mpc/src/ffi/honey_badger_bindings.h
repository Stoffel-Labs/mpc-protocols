/* Don't modify this file manually. It is autogenerated by cbindgen. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define F2_8_MODULUS 283

typedef enum ProtocolType {
  None = 0,
  Randousha = 1,
  Ransha = 2,
  Input = 3,
  Rbc = 4,
  Triple = 5,
  BatchRecon = 6,
  Dousha = 7,
  Mul = 8,
  PRandInt = 9,
  PRandBit = 10,
  RandBit = 11,
  FpMul = 12,
  Trunc = 13,
  FpDivConst = 14,
} ProtocolType;

typedef enum FieldKind {
  Bls12_381Fr,
} FieldKind;

typedef enum HoneyBadgerErrorCode {
  HoneyBadgerSuccess,
  HoneyBadgerNetworkError,
  HoneyBadgerRanShaError,
  HoneyBadgerInputError,
  HoneyBadgerDouShaError,
  HoneyBadgerRanDouShaError,
  HoneyBadgerNotEnoughPreprocessing,
  HoneyBadgerTripleGenError,
  HoneyBadgerRbcError,
  HoneyBadgerMulError,
  HoneyBadgerOutputError,
  HoneyBadgerBatchReconError,
  HoneyBadgerBincodeSerializationError,
  HoneyBadgerJoinError,
  HoneyBadgerChannelClosed,
  HoneyBadgerOutputNotReady,
  HoneyBadgerRandBitError,
  HoneyBadgerPRandError,
  HoneyBadgerFPMulError,
  HoneyBadgerTruncPrError,
  HoneyBadgerFPDivConstError,
  HoneyBadgerTypesError,
  HoneyBadgerAlreadyReservedError,
} HoneyBadgerErrorCode;

typedef enum NetworkErrorCode {
  NetworkSuccess,
  IncorrectNetworkType,
  IncorrectSockAddr,
  ConnectError,
  NetworkAlreadyInUse,
  RecvError,
  SendError,
  Timeout,
  PartyNotFound,
  ClientNotFound,
} NetworkErrorCode;

typedef enum RbcMessageType {
  BrachaInit,
  BrachaEcho,
  BrachaReady,
  BrachaUnknown,
  AvidSend,
  AvidEcho,
  AvidReady,
  AvidUnknown,
  AbaEst,
  AbaAux,
  AbaKey,
  AbaCoin,
  AbaUnknown,
  Acs,
  AcsUnknown,
} RbcMessageType;

typedef enum RbcErrorCode {
  RbcSuccess,
  RbcInvalidThreshold,
  RbcSessionEnded,
  RbcUnknownMsgType,
  RbcSendFailed,
  RbcInternal,
  RbcNetworkSendError,
  RbcNetworkTimeout,
  RbcNetworkPartyNotFound,
  RbcNetworkClientNotFound,
  RbcSerializationError,
  RbcShardError,
  RbcSessionNotFound,
} RbcErrorCode;

typedef enum ShareErrorCode {
  ShareSuccess,
  InsufficientShares,
  DegreeMismatch,
  IdMismatch,
  InvalidInput,
  TypeMismatch,
  NoSuitableDomain,
  PolynomialOperationError,
  DecodingError,
} ShareErrorCode;

/**
 * Finite field GF(2^8) with AES modulus x^8 + x^4 + x^3 + x + 1 (0x11B)
 */
typedef struct F2_8 F2_8;

typedef struct U256 {
  uint64_t data[4];
} U256;

typedef struct U256Slice {
  struct U256 *pointer;
  uintptr_t len;
} U256Slice;

typedef struct ByteSlice {
  uint8_t *pointer;
  uintptr_t len;
} ByteSlice;

typedef struct HoneyBadgerMPCClientOpaque {

} HoneyBadgerMPCClientOpaque;

typedef struct NetworkOpaque {

} NetworkOpaque;

typedef struct UsizeSlice {
  uintptr_t *pointer;
  uintptr_t len;
} UsizeSlice;

typedef struct FakeNetworkReceiversOpaque {

} FakeNetworkReceiversOpaque;

typedef struct QuicNetworkOpaque {

} QuicNetworkOpaque;

typedef struct QuicPeerConnectionsOpaque {

} QuicPeerConnectionsOpaque;

typedef struct RbcMsg {
  uintptr_t sender_id;
  uint64_t session_id;
  uintptr_t round_id;
  struct ByteSlice payload;
  struct ByteSlice metadata;
  enum RbcMessageType msg_type;
  uintptr_t msg_len;
} RbcMsg;

typedef struct BrachaOpaque {

} BrachaOpaque;

typedef struct AvidOpaque {

} AvidOpaque;

typedef struct AbaOpaque {

} AbaOpaque;

typedef struct FieldOpaque {

} FieldOpaque;

typedef struct ShamirShare {
  struct FieldOpaque *share;
  uintptr_t id;
  uintptr_t degree;
} ShamirShare;

typedef struct RobustShare {
  struct FieldOpaque *share;
  uintptr_t id;
  uintptr_t degree;
} RobustShare;

typedef struct NonRobustShare {
  struct FieldOpaque *share;
  uintptr_t id;
  uintptr_t degree;
} NonRobustShare;

typedef struct ShamirShareSlice {
  struct ShamirShare *pointer;
  uintptr_t len;
} ShamirShareSlice;

typedef struct RobustShareSlice {
  struct RobustShare *pointer;
  uintptr_t len;
} RobustShareSlice;

typedef struct NonRobustShareSlice {
  struct NonRobustShare *pointer;
  uintptr_t len;
} NonRobustShareSlice;



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

void free_u256_slice(struct U256Slice slice);

void free_bytes_slice(struct ByteSlice slice);

void free_c_string(char *ptr);

struct U256 be_bytes_to_u256(struct ByteSlice bytes);

struct U256 le_bytes_to_u256(struct ByteSlice bytes);

struct ByteSlice u256_to_be_bytes(struct U256 num);

struct ByteSlice u256_to_le_bytes(struct U256 num);

uint64_t new_session_id(enum ProtocolType caller,
                        uint8_t exec_id,
                        uint8_t sub_id,
                        uint8_t round_id,
                        uint32_t instance_id);

enum ProtocolType calling_protocol(uint64_t session_id);

uint8_t exec_id(uint64_t session_id);

uint8_t sub_id(uint64_t session_id);

uint8_t round_id(uint64_t session_id);

uint32_t instance_id(uint64_t session_id);

struct HoneyBadgerMPCClientOpaque *new_honey_badger_mpc_client(uintptr_t id,
                                                               uintptr_t n,
                                                               uintptr_t t,
                                                               uint32_t instance_id,
                                                               struct U256Slice inputs,
                                                               uintptr_t input_len,
                                                               enum FieldKind field_kind);

enum HoneyBadgerErrorCode hb_client_process(struct HoneyBadgerMPCClientOpaque *client_ptr,
                                            struct NetworkOpaque *net_ptr,
                                            struct ByteSlice raw_msg);

enum HoneyBadgerErrorCode hb_client_get_output(struct HoneyBadgerMPCClientOpaque *client_ptr,
                                               struct U256 *returned_output,
                                               enum FieldKind field_kind);

void free_honey_badger_mpc_client(struct HoneyBadgerMPCClientOpaque *client_ptr);

void free_network(struct NetworkOpaque *network);

struct NetworkOpaque *clone_network(struct NetworkOpaque *network);

enum NetworkErrorCode network_send(struct NetworkOpaque *net_ptr,
                                   uintptr_t recipient_id,
                                   struct ByteSlice message,
                                   uintptr_t *sent_size);

struct NetworkOpaque *new_fake_network(uintptr_t n_nodes,
                                       const struct UsizeSlice *n_clients,
                                       uintptr_t channel_buff_size,
                                       struct FakeNetworkReceiversOpaque **returned_receivers);

struct ByteSlice node_receiver_recv_sync(struct FakeNetworkReceiversOpaque *receivers,
                                         uintptr_t node_index);

void free_fake_network_receivers(struct FakeNetworkReceiversOpaque *receivers);

/**
 * Select crypto provider for rustls
 * Must be called before using quic network
 */
void init_tls(void);

/**
 * Creates a new QUIC network instance
 *
 * This initializes a network manager with no active endpoints or configurations.
 * Before using the manager, you must call either `connect()` or `listen()`
 * to set up the appropriate endpoint.
 * It also initializes a peer connection map.
 */
struct QuicNetworkOpaque *new_quic_network(struct QuicPeerConnectionsOpaque **returned_connections);

/**
 * Establishes a connection to a new peer
 *
 * This method initiates an outgoing connection to a peer at the specified address.
 * It handles the connection establishment process, including any necessary
 * handshaking, encryption setup, and protocol negotiation.
 *
 * # Arguments
 * * `address` - The network address of the peer to connect to
 */
enum NetworkErrorCode quic_connect(struct QuicNetworkOpaque *quic_network_ptr,
                                   struct QuicPeerConnectionsOpaque *peer_connections,
                                   const char *addr);

/**
 * Accepts an incoming connection
 *
 * This method accepts a pending incoming connection from a peer.
 * It should be called after `listen()` has been called to set up
 * the listening endpoint.
 *
 * This method will block until a connection is available or an error occurs.
 */
enum NetworkErrorCode quic_accept(struct QuicNetworkOpaque *quic_network_ptr,
                                  struct QuicPeerConnectionsOpaque *peer_connections,
                                  char **connected_addr);

/**
 * Listens for incoming connections
 *
 * This method sets up a network endpoint to listen for incoming connections
 * at the specified address. After calling this method, `accept()` can be
 * called to accept incoming connections.
 *
 * # Arguments
 * * `bind_address` - The local address to bind to for listening
 */
enum NetworkErrorCode quic_listen(struct QuicNetworkOpaque *quic_network_ptr,
                                  const char *bind_address);

/**
 * Cast a QUIC network into HoneyBadgerMPC network.
 * This method will comsume the original pointer and set it to Null.
 * Make sure to finish QUIC setup before this function.
 */
struct NetworkOpaque *quic_into_hb_network(struct QuicNetworkOpaque **quic_network_ptr);

enum NetworkErrorCode quic_receive_from_sync(struct QuicPeerConnectionsOpaque *peer_connections,
                                             const char *addr,
                                             struct ByteSlice *msg);

enum NetworkErrorCode quic_send(struct QuicPeerConnectionsOpaque *peer_connections,
                                const char *recp,
                                struct ByteSlice msg);

void free_quic_network(struct QuicNetworkOpaque *quic_network_ptr);

void free_quic_peer_connections(struct QuicPeerConnectionsOpaque *peer_connections);

void free_rbc_msg(struct RbcMsg msg);

enum RbcErrorCode deserialize_rbc_msg(struct ByteSlice msg, struct RbcMsg *output_rbc_msg);

/**
 * Creates a new Bracha instance with the given parameters.
 *
 * # Arguments
 * * `id` - the ID of the initiator
 * * `n` - total number of parties in the network
 * * `t` - number of allowed malicious parties
 */
enum RbcErrorCode bracha_new(uintptr_t id,
                             uintptr_t n,
                             uintptr_t t,
                             struct BrachaOpaque **bracha_pointer);

void free_bracha(struct BrachaOpaque *bracha_pointer);

uintptr_t get_bracha_id(struct BrachaOpaque *bracha_pointer);

uintptr_t get_bracha_n(struct BrachaOpaque *bracha_pointer);

uintptr_t get_bracha_t(struct BrachaOpaque *bracha_pointer);

void sync_bracha_clear_store(struct BrachaOpaque *bracha_pointer);

enum RbcErrorCode has_bracha_session_ended(struct BrachaOpaque *bracha_pointer,
                                           uint64_t session_id,
                                           bool *output);

enum RbcErrorCode get_bracha_output(struct BrachaOpaque *bracha_pointer,
                                    uint64_t session_id,
                                    struct ByteSlice *output);

enum RbcErrorCode sync_bracha_init(struct BrachaOpaque *bracha_pointer,
                                   struct ByteSlice payload,
                                   uint64_t session_id,
                                   struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_bracha_process(struct BrachaOpaque *bracha_pointer,
                                      struct RbcMsg msg,
                                      struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_bracha_broadcast(struct BrachaOpaque *bracha_pointer,
                                        struct RbcMsg msg,
                                        struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_bracha_send(struct BrachaOpaque *bracha_pointer,
                                   struct RbcMsg msg,
                                   struct NetworkOpaque *net_ptr,
                                   uintptr_t recv);

/**
 * Creates a new Avid instance with the given parameters.
 */
enum RbcErrorCode avid_new(uintptr_t id,
                           uintptr_t n,
                           uintptr_t t,
                           uintptr_t k,
                           struct AvidOpaque **avid_pointer);

void free_avid(struct AvidOpaque *avid_pointer);

uintptr_t get_avid_id(struct AvidOpaque *avid_pointer);

uintptr_t get_avid_n(struct AvidOpaque *avid_pointer);

uintptr_t get_avid_t(struct AvidOpaque *avid_pointer);

void sync_avid_clear_store(struct AvidOpaque *avid_pointer);

enum RbcErrorCode has_avid_session_ended(struct AvidOpaque *avid_pointer,
                                         uint64_t session_id,
                                         bool *output);

enum RbcErrorCode get_avid_output(struct AvidOpaque *avid_pointer,
                                  uint64_t session_id,
                                  struct ByteSlice *output);

enum RbcErrorCode sync_avid_init(struct AvidOpaque *avid_pointer,
                                 struct ByteSlice payload,
                                 uint64_t session_id,
                                 struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_avid_process(struct AvidOpaque *avid_pointer,
                                    struct RbcMsg msg,
                                    struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_avid_broadcast(struct AvidOpaque *avid_pointer,
                                      struct RbcMsg msg,
                                      struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_avid_send(struct AvidOpaque *avid_pointer,
                                 struct RbcMsg msg,
                                 struct NetworkOpaque *net_ptr,
                                 uintptr_t recv);

/**
 * Creates a new Avid instance with the given parameters.
 */
enum RbcErrorCode aba_new(uintptr_t id,
                          uintptr_t n,
                          uintptr_t t,
                          uintptr_t k,
                          struct AbaOpaque **aba_pointer);

void free_aba(struct AbaOpaque *aba_pointer);

uintptr_t get_aba_id(struct AbaOpaque *aba_pointer);

uintptr_t get_aba_n(struct AbaOpaque *aba_pointer);

uintptr_t get_aba_t(struct AbaOpaque *aba_pointer);

void sync_aba_clear_store(struct AbaOpaque *aba_pointer);

enum RbcErrorCode has_aba_session_ended(struct AbaOpaque *aba_pointer,
                                        uint64_t session_id,
                                        bool *output);

enum RbcErrorCode get_aba_output(struct AbaOpaque *aba_pointer, uint64_t session_id, bool *output);

enum RbcErrorCode sync_aba_init(struct AbaOpaque *aba_pointer,
                                struct ByteSlice payload,
                                uint64_t session_id,
                                struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_aba_process(struct AbaOpaque *aba_pointer,
                                   struct RbcMsg msg,
                                   struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_aba_broadcast(struct AbaOpaque *aba_pointer,
                                     struct RbcMsg msg,
                                     struct NetworkOpaque *net_ptr);

enum RbcErrorCode sync_aba_send(struct AbaOpaque *aba_pointer,
                                struct RbcMsg msg,
                                struct NetworkOpaque *net_ptr,
                                uintptr_t recv);

struct ByteSlice field_ptr_to_bytes(struct FieldOpaque *field, bool be);

void free_shamir_share(struct ShamirShare share);

void free_robust_share(struct RobustShare share);

void free_non_robust_share(struct NonRobustShare share);

void free_shamir_share_slice(struct ShamirShareSlice slice);

void free_robust_share_slice(struct RobustShareSlice slice);

void free_non_robust_share_slice(struct NonRobustShareSlice slice);

struct ShamirShare shamir_share_new(struct U256 secret,
                                    uintptr_t id,
                                    uintptr_t degree,
                                    enum FieldKind field_kind);

enum ShareErrorCode shamir_share_compute_shares(struct U256 secret,
                                                uintptr_t degree,
                                                const struct UsizeSlice *ids,
                                                enum FieldKind field_kind,
                                                struct ShamirShareSlice *output_shares);

enum ShareErrorCode shamir_share_recover_secret(struct ShamirShareSlice shares,
                                                struct U256 *output_secret,
                                                struct U256Slice *output_coeffs,
                                                enum FieldKind field_kind);

struct RobustShare robust_share_new(struct U256 secret,
                                    uintptr_t id,
                                    uintptr_t degree,
                                    enum FieldKind field_kind);

/**
 * Generates `n` secret shares for a `value` using a degree `t` polynomial,
 * such that `f(0) = value`. Any `t + 1` shares can reconstruct the secret.
 *
 * Shares are evaluations of `f(x)` on an FFT domain.
 *
 * # Errors
 * - `InvalidInput` if `n` is not greater than `t`.
 * - `NoSuitableDomain` if a suitable FFT evaluation domain of size `n` isn't found.
 */
enum ShareErrorCode robust_share_compute_shares(struct U256 secret,
                                                uintptr_t degree,
                                                uintptr_t n,
                                                struct RobustShareSlice *output_shares,
                                                enum FieldKind field_kind);

/**
 * Full robust interpolation combining optimistic decoding and error correction
 *
 * # Arguments
 * * `n` - total number of shares
 * * `shares` - pointer to the RobustShareSlice, unordered
 */
enum ShareErrorCode robust_share_recover_secret(struct RobustShareSlice shares,
                                                uintptr_t n,
                                                struct U256 *output_secret,
                                                struct U256Slice *output_coeffs,
                                                enum FieldKind field_kind);

struct NonRobustShare non_robust_share_new(struct U256 secret,
                                           uintptr_t id,
                                           uintptr_t degree,
                                           enum FieldKind field_kind);

enum ShareErrorCode non_robust_share_compute_shares(struct U256 secret,
                                                    uintptr_t degree,
                                                    uintptr_t n,
                                                    struct NonRobustShareSlice *output_shares,
                                                    enum FieldKind field_kind);

enum ShareErrorCode non_robust_share_recover_secret(struct NonRobustShareSlice shares,
                                                    uintptr_t n,
                                                    struct U256 *output_secret,
                                                    struct U256Slice *output_coeffs,
                                                    enum FieldKind field_kind);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
