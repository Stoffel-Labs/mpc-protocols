use std::collections::HashMap;

use ark_ff::FftField;
use ark_serialize::SerializationError;
use bincode::ErrorKind;
use serde::{Deserialize, Serialize};
use stoffelnet::network_utils::NetworkError;
use thiserror::Error;
use tokio::sync::mpsc::error::SendError;

use crate::{
    common::{rbc::RbcError, share::ShareError},
    honeybadger::{
        robust_interpolate::{robust_interpolate::RobustShare, InterpolateError},
        SessionId,
    },
};

pub mod batched_share_gen;
pub mod share_gen;

/// Error type for the Random Single Share (RanSha) protocol.
#[derive(Debug, Error)]
pub enum RanShaError {
    #[error("there was an error in the network: {0:?}")]
    NetworkError(#[from] NetworkError),
    #[error("error while serializing an arkworks object: {0:?}")]
    ArkSerialization(#[from] SerializationError),
    #[error("error while serializing an arkworks object: {0:?}")]
    ArkDeserialization(SerializationError),
    #[error("error while serializing the object into bytes: {0:?}")]
    SerializationError(#[from] Box<ErrorKind>),
    #[error("inner error: {0:?}")]
    InterpolateError(#[from] InterpolateError),
    #[error("Rbc error: {0:?}")]
    RbcError(#[from] RbcError),
    #[error("Share error: {0:?}")]
    ShareError(#[from] ShareError),
    #[error("error sending the output of the protocol execution: {0:?}")]
    SendError(#[from] SendError<SessionId>),
    #[error("received abort signal")]
    Abort,
    #[error("waiting for more confirmations")]
    WaitForOk,
}

#[derive(Clone, Debug)]
pub struct RanShaStore<F: FftField> {
    pub initial_shares: HashMap<usize, RobustShare<F>>,
    pub reception_tracker: Vec<bool>,
    pub received_r_shares: HashMap<usize, RobustShare<F>>,
    pub computed_r_shares: Vec<RobustShare<F>>,
    pub received_ok_msg: Vec<usize>,
    pub state: RanShaState,
    pub protocol_output: Vec<RobustShare<F>>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RanShaState {
    Initialized,
    FinishedInitialSharing,
    Reconstruction,
    Output,
    Finished,
}

impl<F: FftField> RanShaStore<F> {
    pub fn empty(n_parties: usize) -> Self {
        Self {
            initial_shares: HashMap::new(),
            reception_tracker: vec![false; n_parties],
            received_r_shares: HashMap::new(),
            computed_r_shares: Vec::new(),
            received_ok_msg: Vec::new(),
            state: RanShaState::Initialized,
            protocol_output: Vec::new(),
        }
    }
}

/// Storage for batched random share generation.
/// Instead of storing 1 share per party, stores K shares per party.
#[derive(Clone, Debug)]
pub struct BatchedRanShaStore<F: FftField> {
    /// K shares received from each party (party_id -> Vec of K shares)
    pub initial_shares: HashMap<usize, Vec<RobustShare<F>>>,
    /// Tracks which parties have sent their batched shares
    pub reception_tracker: Vec<bool>,
    /// K*n computed r shares after Vandermonde transformation
    pub computed_r_shares: Vec<RobustShare<F>>,
    /// Received reconstruction shares (for verification)
    pub received_r_shares: HashMap<usize, Vec<RobustShare<F>>>,
    /// Parties who have confirmed successful reconstruction
    pub received_ok_msg: Vec<usize>,
    /// Current protocol state
    pub state: RanShaState,
    /// Final output: K*(n-2t) random shares
    pub protocol_output: Vec<RobustShare<F>>,
    /// Batch size K (number of secrets per party)
    pub batch_size: usize,
}

impl<F: FftField> BatchedRanShaStore<F> {
    pub fn new(n_parties: usize, batch_size: usize) -> Self {
        Self {
            initial_shares: HashMap::with_capacity(n_parties),
            reception_tracker: vec![false; n_parties],
            computed_r_shares: Vec::with_capacity(batch_size * n_parties),
            received_r_shares: HashMap::new(),
            received_ok_msg: Vec::new(),
            state: RanShaState::Initialized,
            protocol_output: Vec::new(),
            batch_size,
        }
    }
}

/// Types for all the possible messages sent during the Random Single Sharing protocol.
#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]
pub enum RanShaMessageType {
    //Initial shares generated by each parties that could be faulty
    ShareMessage,
    /// Tag for the message received by the reconstruction handler.
    ReconstructMessage,
    /// Tag for the message received by the output handler.
    OutputMessage,
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub enum RanShaPayload {
    Share(Vec<u8>),
    /// Contains the share of r sent during reconstruction.
    Reconstruct(Vec<u8>),
    /// Output message confirming reconstruction success or failure.
    Output(bool),
    /// Batched shares: K shares serialized together
    BatchedShare(Vec<u8>),
    /// Batched reconstruction: K shares for reconstruction
    BatchedReconstruct(Vec<u8>),
}

/// Message sent in the Random Single Sharing protocol.
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct RanShaMessage {
    /// ID of the sender of the message.
    pub sender_id: usize,
    /// Type of the message according to the handler.
    pub msg_type: RanShaMessageType,
    /// Session ID of the execution.
    pub session_id: SessionId,
    /// Contents of the message.
    pub payload: RanShaPayload,
}

impl RanShaMessage {
    pub fn new(
        sender_id: usize,
        msg_type: RanShaMessageType,
        session_id: SessionId,
        payload: RanShaPayload,
    ) -> Self {
        Self {
            sender_id,
            msg_type,
            session_id,
            payload,
        }
    }
}
