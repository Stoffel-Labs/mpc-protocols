use std::{collections::HashMap, sync::Arc};

use ark_ff::FftField;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::rand::Rng;
use bincode::ErrorKind;
use itertools::izip;
use serde::{Deserialize, Serialize};
use stoffelmpc_network::{Message, Network, NetworkError, Node, PartyId, SessionId};
use thiserror::Error;
use tokio::sync::Mutex;
use tracing::info;

use crate::common::{
    share::{shamir::NonRobustShamirShare, ShareError},
    SecretSharingScheme,
};

use super::DoubleShamirShare;

/// Error for the faulty double share distribution protocol.
#[derive(Debug, Error)]
pub enum DouShaError {
    /// The sender ID does not match with the expected ID.
    #[error(
        "sender mismatch: expected sender: {expected_sender:?}, actual_sender: {actual_sender:?}"
    )]
    SenderMismatch {
        expected_sender: PartyId,
        actual_sender: PartyId,
    },
    /// There was an error when manipulating shares.
    #[error("error in share: {0:?}")]
    ShareError(#[from] ShareError),
    /// Error in the serialization using `arkworks`.
    #[error("ark serialization error: {0:?}")]
    ArkSerializationError(#[from] ark_serialize::SerializationError),
    /// Error in the serialization using `bincode`.
    #[error("bincode serialization error: {0:?}")]
    BincodeSerializationError(#[from] Box<ErrorKind>),
    /// Error during a network operation.
    #[error("error in the network: {0:?}")]
    NetworkError(#[from] NetworkError),
}

/// Generic message for the faulty double share distribution protocol.
#[derive(Serialize, Deserialize)]
pub struct DouShaMessage {
    /// ID of the sender.
    sender_id: PartyId,
    /// ID of the session.
    session_id: SessionId,
    /// Type of the message in the protocol execution.
    msg_type: DouShaMessageType,
    /// Payload of the message.
    payload: Vec<u8>,
}

impl Message for DouShaMessage {
    fn sender_id(&self) -> PartyId {
        self.sender_id
    }

    fn bytes(&self) -> &[u8] {
        &self.payload
    }
}

impl DouShaMessage {
    /// Creates a new generic message for the faulty double share protocol.
    pub fn new(
        sender: PartyId,
        session_id: SessionId,
        msg_type: DouShaMessageType,
        payload: Vec<u8>,
    ) -> Self {
        Self {
            sender_id: sender,
            session_id,
            msg_type,
            payload,
        }
    }
}

/// Type of messages sent during the faulty double share protocol.
#[derive(PartialEq, Serialize, Deserialize)]
pub enum DouShaMessageType {
    /// Message that contains the shares generated by the sender.
    Receive,
}

#[derive(PartialEq)]
pub enum ProtocolState {
    Initialized,
    Finished,
    NotInitialized,
}

/// Message that contains the shares received from the sharing process.
#[derive(CanonicalDeserialize, CanonicalSerialize)]
pub struct ReceiveMessage<F: FftField> {
    /// ID of the sender.
    pub sender_id: PartyId,
    /// ID of the session.
    pub session_id: SessionId,
    /// Contains the Shamir shares of degree `t` and `2t` generated by the sender.
    pub double_share: DoubleShamirShare<F>,
}

impl<F> ReceiveMessage<F>
where
    F: FftField,
{
    pub fn new(
        sender_id: usize,
        session_id: SessionId,
        double_share: DoubleShamirShare<F>,
    ) -> Self {
        Self {
            sender_id,
            session_id,
            double_share,
        }
    }
}

/// Storage for the faulty double share protocol.
pub struct DouShaStorage<F>
where
    F: FftField,
{
    /// Double shares resulting from the execution of the protocol.
    pub shares: Vec<DoubleShamirShare<F>>,

    /// Current state of the protocol.
    pub state: ProtocolState,

    /// Tracker for the received shares.
    ///
    /// Each time tha a party receives a share, the boolean vector in its position is set to
    /// `true`. The protocol is finished once all the flags of the vector are `true`.
    reception_tracker: Vec<bool>,
}

impl<F> DouShaStorage<F>
where
    F: FftField,
{
    /// Creates an empty storage. The
    pub fn empty(n_parties: usize) -> Self {
        Self {
            shares: Vec::new(),
            reception_tracker: vec![false; n_parties],
            state: ProtocolState::NotInitialized,
        }
    }
}

/// Parameters for the faulty double share protocol.
#[derive(Debug, Clone)]
pub struct DouShaParams {
    /// ID of the session.
    pub session_id: SessionId,
    /// Number of parties participating in the protocol.
    pub n_parties: usize,
    /// Threshold for the corrupted parties.
    pub threshold: usize,
}

impl DouShaParams {
    /// Creates a new double share parameter set.
    pub fn new(session_id: SessionId, n_parties: usize, threshold: usize) -> Self {
        assert!(threshold < n_parties);
        Self {
            session_id,
            n_parties,
            threshold,
        }
    }
}

/// Node participating in a non-robust double share protocol.
pub struct DoubleShareNode<F>
where
    F: FftField,
{
    /// ID of the party.
    pub id: PartyId,
    /// Storage of the party.
    pub storage: Arc<Mutex<HashMap<SessionId, Arc<Mutex<DouShaStorage<F>>>>>>,
}

impl<F> DoubleShareNode<F>
where
    F: FftField,
{
    pub async fn proccess<R, N>(
        &mut self,
        params: &DouShaParams,
        message: &DouShaMessage,
        rng: &mut R,
        network: Arc<N>,
    ) -> Result<(), DouShaError>
    where
        R: Rng,
        N: Network,
    {
        match message.msg_type {
            DouShaMessageType::Receive => {
                let receive_message =
                    ReceiveMessage::deserialize_compressed(message.payload.as_slice())?;
                self.receive_double_shares_handler(&params, &receive_message)
                    .await?;
                Ok(())
            }
        }
    }

    /// Creates a new node for the faulty double share protocol.
    pub fn new(id: PartyId) -> Self {
        Self {
            id,
            storage: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Returns the storage for a node in the Random Double Sharing protocol. If the storage has
    /// not been created yet, the function will create an empty storage and return it.
    pub async fn get_or_create_store(
        &mut self,
        n_parties: usize,
        session_id: SessionId,
    ) -> Arc<Mutex<DouShaStorage<F>>> {
        let mut storage = self.storage.lock().await;
        storage
            .entry(session_id)
            .or_insert(Arc::new(Mutex::new(DouShaStorage::empty(n_parties))))
            .clone()
    }

    pub async fn init<N, R>(
        &mut self,
        session_id: SessionId,
        params: &DouShaParams,
        rng: &mut R,
        network: Arc<N>,
    ) -> Result<(), DouShaError>
    where
        N: Network,
        R: Rng,
    {
        info!("Receiving init for faulty double share from {0:?}", self.id);

        let ids: Vec<PartyId> = network.parties().iter().map(|party| party.id()).collect();

        let secret = F::rand(rng);

        let shares_deg_t = NonRobustShamirShare::compute_shares(
            secret,
            params.n_parties,
            params.threshold,
            Some(&ids),
            rng,
        )?;
        let shares_deg_2t = NonRobustShamirShare::compute_shares(
            secret,
            params.n_parties,
            2 * params.threshold,
            Some(&ids),
            rng,
        )?;

        let id_parties: Vec<PartyId> = network.parties().iter().map(|party| party.id()).collect();

        for (share_t, share_2t, recipient_id) in izip!(shares_deg_t, shares_deg_2t, id_parties) {
            // Create and serialize the payload.
            let double_share = DoubleShamirShare::new(share_t, share_2t);
            let message = ReceiveMessage::new(self.id, session_id, double_share);
            let mut payload = Vec::new();
            message.serialize_compressed(&mut payload)?;

            // Create and serialize the generic message.
            let generic_message =
                DouShaMessage::new(self.id, session_id, DouShaMessageType::Receive, payload);
            let bytes_generic_msg = bincode::serialize(&generic_message)?;

            info!(
                "sending shares from {:?} to {:?}",
                self.id, message.double_share.degree_t.id
            );
            network.send(recipient_id, &bytes_generic_msg).await?;
        }

        // Update the state of the protocol to Initialized.
        let storage_access = self
            .get_or_create_store(params.n_parties, params.session_id)
            .await;
        let mut storage = storage_access.lock().await;
        storage.state = ProtocolState::Initialized;

        Ok(())
    }

    pub async fn receive_double_shares_handler(
        &mut self,
        params: &DouShaParams,
        recv_message: &ReceiveMessage<F>,
    ) -> Result<(), DouShaError> {
        let binding = self
            .get_or_create_store(params.n_parties, recv_message.session_id)
            .await;
        let mut dousha_storage = binding.lock().await;
        dousha_storage
            .shares
            .push(recv_message.double_share.clone());
        info!(
            session_id = recv_message.session_id,
            share_amount = dousha_storage.shares.len(),
            "party {:?} received shares from {:?}",
            self.id,
            recv_message.sender_id,
        );
        dousha_storage.reception_tracker[recv_message.sender_id] = true;

        // Check if the protocol has reached an end
        if dousha_storage
            .reception_tracker
            .iter()
            .all(|&received| received)
        {
            dousha_storage.state = ProtocolState::Finished;
        }

        Ok(())
    }
}
